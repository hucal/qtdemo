// #include <QDebug> // use qWarning << "DEBUG MESSAGE\n" to print to the application output
#include <QDomDocument>
#include <QDir>
#include <QVariant>
#include <QtNetwork>
#include <QUrl>

#include "../model/dataobject.h"

/* generated by generate_qobject.py (Hugo Rivera, 2016) */
#include "classreader.h"

ClassReader::ClassReader(QObject *parent)
    : ClassReader(QList<QObject*>(), QUrl(), parent)
{ }

ClassReader::ClassReader(const QList<QObject*> &classes, const QUrl &url, QObject *parent)
   : QObject(parent), m_classes(classes), m_url(url)
{ }

void ClassReader::setClasses(QList<QObject*> classes)
{
   if (classes != m_classes) {
       m_classes = classes;
       emit classesChanged();
   }
}

void ClassReader::setUrl(QUrl url)
{
   if (url != m_url) {
       m_url = url;
       emit urlChanged();
   }
}

QList<QObject*> ClassReader::classes() const
{
   return m_classes;
}

QVariant ClassReader::classesAsVariant() const
{
    return QVariant::fromValue(classes());
}

QUrl ClassReader::url() const
{
   return m_url;
}

// see httpwindow's downloadFile, startRequest

// this function should communicate with the networkManager object to start a download
// the QNetworkRequest is created using the QUrl in the url() method:
// ...newnetworkrequest...(url())
// and the QNetworkReply is stored as a private attribute reply
// (like in httpwindow)
void ClassReader::startDownload()
{
    //TODO figure out why !file is true
    const QString &urlSpec = "0.0.0.0:8000/classes.xml";

    const QUrl newUrl = QUrl::fromUserInput(urlSpec);
    if (!newUrl.isValid()) {
        emit networkError(QString("Invalid URL: %1").arg(urlSpec));
        return;
    }

    QString writeFile = newUrl.fileName();
    if (writeFile.isEmpty())
        writeFile = "classes.xml"; //temporary
    QString downloadDir = "/home/grime/Desktop/";
    if (!downloadDir.isEmpty() && QFileInfo(downloadDir).isDir())
        writeFile.prepend(downloadDir + '/');

    file = openFileForWrite(writeFile);

    if (!file) // this is true ; not sure why
        emit networkError(QString("could not open file)"));
        //return;

    m_url = newUrl;

    reply = networkManager.get(QNetworkRequest(m_url));
    connect(reply, &QNetworkReply::finished, this, &ClassReader::httpFinished);
    connect(reply, &QIODevice::readyRead, this, &ClassReader::parseClasses);

}

QFile *ClassReader::openFileForWrite(const QString &fileName)
{
    QScopedPointer<QFile> file(new QFile(fileName));
    if (!file->open(QIODevice::WriteOnly)) {
        // throw an error
        return Q_NULLPTR;
    }
    return file.take();
}

void ClassReader::httpFinished()
{
    //TODO emit network errors
    QFileInfo fi;
    if (file) {
        fi.setFile(file->fileName());
        file->close();
        delete file;
        file = Q_NULLPTR;
    }

    if (reply->error()) {
        QFile::remove(fi.absoluteFilePath());
        reply->deleteLater();
        reply = Q_NULLPTR;
        return;
    }

    reply->deleteLater();
    reply = Q_NULLPTR;
}


void ClassReader::parseClasses()
{
    // TODO define the variable bytearray based on reply
    // see QIODevice documentation
    // see httpwindow's readyRead
    if (file)
        file->write(reply->readAll());

    QByteArray bytearray("<classes><class name='Hardcoded class 1' location='Cramer 6.285714'/><class location='Weir 3.1415' name='Hardcoded class 2'/></classes>");

    QDomDocument doc("classes");

    emit parsingError(QString("sample parsing error, not an error"));

    // parse the XML and add all classes to the classes attribute
    if (doc.setContent(bytearray)) {
        m_classes.clear();

        // parse root tag <classes>
        QDomElement root = doc.documentElement();
        if (root.isNull() || root.tagName() != "classes") {
            emit parsingError(QString("expected <classes> as root element."));
            return;
        }

        // parse all <class> tags
        QDomElement child = root.firstChildElement("class");
        while (!child.isNull()) {
            QString attr_name;
            QString attr_location;
            if (child.hasAttribute("name")) {
                attr_name = child.attribute("name");
            } else {
                emit parsingError(QString("expected name property"));
                return;
            }
            if (child.hasAttribute("location")) {
                attr_location = child.attribute("location");
            } else {
                emit parsingError(QString("expected location property"));
                return;
            }

            m_classes.append(new DataObject(attr_name, attr_location));
            child = child.nextSiblingElement("class");
        }
        if (m_classes.length() > 0) {
            emit classesChanged();
            return;
        } else {
            emit parsingError(QString("expected at least one <class> tag"));
            return;
        }
    } else {
        emit parsingError(QString("could not parse bytearray as an XML"));
        return;
    }

}
