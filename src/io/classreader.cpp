// #include <QDebug> // use qWarning << "DEBUG MESSAGE\n" to print to the application output
#include <QDomDocument>
#include <QDir>
#include <QVariant>
#include "../model/dataobject.h"

/* generated by generate_qobject.py (Hugo Rivera, 2016) */
#include "classreader.h"

ClassReader::ClassReader(QObject *parent)
    : ClassReader(QList<QObject*>(), QUrl(), parent)
{ }

ClassReader::ClassReader(const QList<QObject*> &classes, const QUrl &url, QObject *parent)
   : QObject(parent), m_classes(classes), m_url(url)
{ }

void ClassReader::setClasses(QList<QObject*> classes)
{
   if (classes != m_classes) {
       m_classes = classes;
       emit classesChanged();
   }
}

void ClassReader::setUrl(QUrl url)
{
   if (url != m_url) {
       m_url = url;
       emit urlChanged();
   }
}

QList<QObject*> ClassReader::classes() const
{
   return m_classes;
}

QVariant ClassReader::classesAsVariant() const
{
    return QVariant::fromValue(classes());
}

QUrl ClassReader::url() const
{
   return m_url;
}

// see httpwindow's downloadFile, startRequest

// this function should communicate with the networkManager object to start a download
// the QNetworkRequest is created using the QUrl in the url() method:
// ...newnetworkrequest...(url())
// and the QNetworkReply is stored as a private attribute reply
// (like in httpwindow)
void ClassReader::startDownload()
{
    // need something like:
    // connect(reply, QNetworkReply::finished, this, SLOT(httpFinished()));
    // connect(reply, QIODevice::readyRead, this, SLOT(parseClasses()));
    parseClasses();
}

void ClassReader::httpFinished()
{
    // almost directly from httpwindow
    // emit an error signal on errors; slots should accept the error string as an argument
    // emit networkError("error message")
}

void ClassReader::parseClasses()
{
    // TODO define the variable bytearray based on reply
    // see QIODevice documentation
    // see httpwindow's readyRead

    QByteArray bytearray("<classes><class name='Hardcoded class 1' location='Cramer 6.285714'/><class location='Weir 3.1415' name='Hardcoded class 2'/></classes>");

    QDomDocument doc("classes");

    emit parsingError(QString("sample parsing error, not an error"));

    // parse the XML and add all classes to the classes attribute
    if (doc.setContent(bytearray)) {
        m_classes.clear();

        // parse root tag <classes>
        QDomElement root = doc.documentElement();
        if (root.isNull() || root.tagName() != "classes") {
            emit parsingError(QString("expected <classes> as root element."));
            return;
        }

        // parse all <class> tags
        QDomElement child = root.firstChildElement("class");
        while (!child.isNull()) {
            QString attr_name;
            QString attr_location;
            if (child.hasAttribute("name")) {
                attr_name = child.attribute("name");
            } else {
                emit parsingError(QString("expected name property"));
                return;
            }
            if (child.hasAttribute("location")) {
                attr_location = child.attribute("location");
            } else {
                emit parsingError(QString("expected location property"));
                return;
            }

            m_classes.append(new DataObject(attr_name, attr_location));
            child = child.nextSiblingElement("class");
        }
        if (m_classes.length() > 0) {
            emit classesChanged();
            return;
        } else {
            emit parsingError(QString("expected at least one <class> tag"));
            return;
        }
    } else {
        emit parsingError(QString("could not parse bytearray as an XML"));
        return;
    }

}
