from string import Template


def join_dicts(*dicts):
    new_dict = dict()
    for d in dicts:
        for k, v in d.items():
            if k not in new_dict:
                new_dict[k] = v
    return new_dict


def generate_qobject(object_name, props):
    """Returns strings containing C++ code that implements a QObject. Example object_name: "Object Name"."""
    message = "generated by generate_qobject.py (Hugo Rivera, 2016)"
    global_subs = { "message": message,
                    "object_name": object_name.title().replace(" ", ""),
                    "allcaps_object_name": object_name.upper().replace(" ", ""),
                    "object_header_file": object_name.lower().replace(" ", "") + ".h" }

    def get_prop_subs(prop):
        return { "type": prop[1], 
                 "name": prop[0],
                 "member_name": "m_" + prop[0],
                 "capitalized_name": prop[0].capitalize() }

    def prop_template(props, string):
        """Takes a template string and returns a list of strings 
        where each element is the result of applying the template to each property."""
        template = Template(string)
        return [ template.substitute(join_dicts(get_prop_subs(prop), global_subs)) for prop in props ]

    properties = "\n".join(      prop_template("   Q_PROPERTY(${type} ${name} READ ${name} WRITE set${capitalized_name} NOTIFY ${name}Changed)")) 
    ctor_arguments = ", ".join(  prop_template("const ${type} &${name}")) 
    setters = "\n".join(         prop_template("    void set${capitalized_name}(${type} ${name});"))
    getters = "\n".join(         prop_template("    $type ${name}() const;"))
    signals = "\n".join(         prop_template("    void ${name}Changed(${type});"))
    member_variables = "\n".join(prop_template("    ${type} ${member_name};"))
    ctor_definitions = ", ".join(prop_template("${member_name}(${name})"))
    setters_source = "\n\n".join(prop_template("""\
void ${object_name}::set${capitalized_name}(${type} ${name})
{
    if (${name} != ${member_name}) {
        ${member_name} = ${name};
        emit ${name}Changed(${name});
    }
}"""))
    getters_source = "\n\n".join(prop_template("""\
${type} ${object_name}::${name}() const
{ 
    return ${member_name}; 
}"""))
    
    implementation = Template("""\
/* $message */
#include "${object_header_file}"

${object_name}::${object_name}(${ctor_arguments}, QObject *parent)
    : QObject(parent), ${ctor_definitions} 
{
}

${setters_source}

${getters_source}
""").substitute(join_dicts(global_subs,
         {"ctor_arguments": ctor_arguments, 
          "ctor_definitions": ctor_definitions, 
          "setters_source": setters_source, 
          "getters_source": getters_source}))
    
    header = Template("""\
/* $message */
#ifndef ${allcaps_object_name}_H 
#define ${allcaps_object_name}_H

#include <QObject>

class ${object_name} : public QObject
{
    Q_OBJECT

${properties}

public:
    explicit ${object_name}(QObject *parent = 0);

    ${object_name}(${ctor_arguments}, QObject *parent=0);

${setters}

${getters}

signals:
${signals} 

private:
${member_variables}
};

#endif // ${allcaps_object_name}_H 
""").substitute(join_dicts(global_subs, 
        {"properties": properties, 
         "ctor_arguments": ctor_arguments, 
         "setters": setters, 
         "getters": getters, 
         "signals": signals, 
         "member_variables": member_variables}))

    return header, implementation
    
    
if __name__ == "__main__":
    h, s = generate_qobject("Data Object", [("name", "QString"), ("location", "QString")]) 
    print(h, '\n', '-' * 79, '\n', s)
